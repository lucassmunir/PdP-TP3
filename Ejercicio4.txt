
Ejercicio 4: Uso de Caracter√≠sticas de la POO en el Sistema ToDo
La resoluci√≥n del sistema ToDo List en Node.js se bas√≥ fuertemente en la Programaci√≥n Orientada a Objetos (POO) para organizar y modularizar el c√≥digo. Se utilizaron el Encapsulamiento, la Abstracci√≥n y, en menor medida, la Herencia, mientras que el Polimorfismo no se implement√≥.

Caracter√≠sticas de la POO Utilizadas
1. Encapsulamiento üõ°Ô∏è
El encapsulamiento se refiere a agrupar los datos (atributos) con los m√©todos que operan sobre ellos, y restringir el acceso directo a la manipulaci√≥n interna.

Fundamentaci√≥n: Se utiliz√≥ para crear unidades l√≥gicas y autocontenidas, reduciendo la complejidad del sistema general.

Ejemplo de Implementaci√≥n:

Clase Tarea: Encapsula todos los atributos de una tarea (t√≠tulo, estado, dificultad, fechas) y solo expone la l√≥gica para mostrarlos (aCadenaDeVisualizacion).

Clase GestorDeTareas: Encapsula la colecci√≥n interna de tareas (this.tareas) y la l√≥gica de persistencia (cargarTareas, guardarTareas), obligando al resto del sistema a interactuar solo a trav√©s de m√©todos p√∫blicos (agregarTarea, filtrarTareas, editarTarea).

2. Abstracci√≥n üß†
La abstracci√≥n consiste en mostrar solo los detalles relevantes al usuario (o a otras partes del sistema) y ocultar la complejidad interna.

Fundamentaci√≥n: Se utiliz√≥ para simplificar la interacci√≥n entre los m√≥dulos del sistema, separando la l√≥gica de la interfaz.

Ejemplo de Implementaci√≥n:

Clase SistemaToDo: Abstrae al usuario final (Olivia) de c√≥mo se guardan o buscan las tareas. Los men√∫s solo muestran opciones como "Buscar una Tarea" y dependen de los m√©todos del GestorDeTareas sin saber si los datos est√°n en un arreglo o en un archivo JSON.

Clase Tarea: Abstrae la complejidad de la representaci√≥n de la dificultad. El gestor solo manipula un objeto dificultad interno, pero el m√©todo aCadenaDeVisualizacion se encarga de mostrar la representaci√≥n simb√≥lica ‚≠ê‚≠ê‚òÜ al usuario final.

3. Herencia (Parcial) üå≤
La herencia permite que una clase (subclase) adquiera las propiedades y m√©todos de otra (superclase).

Fundamentaci√≥n: Si bien no se utiliz√≥ una herencia directa entre las clases principales, se us√≥ un concepto de herencia funcional a trav√©s de la composici√≥n y el uso de un m√≥dulo base de utilidades.

Ejemplo de Implementaci√≥n:

La clase SistemaToDo "hereda" o reutiliza la funcionalidad de entrada/salida de la consola importando y usando las funciones del m√≥dulo UtilidadesCLI (preguntar, mostrarMenu, pausar).

Caracter√≠sticas de la POO No Implementadas
4. Polimorfismo üé≠
El polimorfismo (del griego "muchas formas") permite que objetos de diferentes clases respondan a la misma llamada de m√©todo de maneras distintas, generalmente a trav√©s de la herencia o de la implementaci√≥n de una interfaz.

Fundamentaci√≥n: Esta caracter√≠stica no fue utilizada ni implementada porque el sistema maneja un √∫nico tipo de entidad: la Tarea.

Justificaci√≥n de la Ausencia:

No fue necesario crear subtipos de tareas (Ej: TareaPersonal, TareaLaboral) que requirieran manejar el mismo m√©todo (guardar, mostrarDetalle) de manera diferente.

Toda la l√≥gica de filtrado y visualizaci√≥n se pudo resolver con un √∫nico m√©todo de clase en GestorDeTareas (filtrarTareas) y un √∫nico m√©todo de instancia en Tarea (aCadenaDeVisualizacion), por lo que no hubo necesidad de aplicar el principio de polimorfismo.